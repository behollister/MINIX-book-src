







			Partition Resizer v. 1.3.4
			==========================
                           (c) Zeleps 1994-2000
                           ====================


		Program's Manual and Technical Information










This file contains important information about the working and usage of
Partition Resizer. Please read it carefully before using Partition Resizer.
You MUST read README.1ST before running Partition Resizer.

DISCLAIMER:
This program is freeware. You may freely copy it and distribute it,as long as
it remains unchanged and it is distributed with its original documents files.
The author is not responsible for any consequence of the use or missuse of
this program. Using this program is completely at your own responsibility.

1- What is Partition Resizer

   1.1 Why you need Partition Resizer
   1.2 How does it work?
   1.3 Is it safe?
   1.4 Changes made to the previous version

2- Working with Partition Resizer

   2.1 Safety precautions
   2.2 Running the program: What does what

3- Technical matters

   3.1 The partition system
   3.2 The DOS (FAT16 and FAT12 only) filesystem structure
   3.3 The Windows FAT32 filesystem structure

4- Partitioning Techniques

   4.1 Deciding what you want
   4.2 Merging many small partitions into a larger one
   4.3 Splitting a partition in two
   4.4 Playing with partitions' sizes and positions

5- Credits and addresses

				-------||-------

1- What is Partition Resizer

   1.1 Why you need Partition Resizer

OK, this is simple: if you have a disk partition (or more), and you want to
change its size or position for any particular reason whatsoever, you have
3 options:

a) Backup everything, use FDISK to delete the partition, re-create the
partition and restore the data.

b) Pay $60 to buy a program that you will use 3 times in your life ($20 per
use)

c) Use Partition Resizer

Always remember: This program does not intend to replace FDISK. It's rather
complementary to it. You will still need FDISK if you want to create and
delete partitions. Partition Resizer processes only existing partitions.
Also, Partition Resizer does not convert FAT16 (older DOS partitions) into
FAT32. Windows 98 provides a tool that does this conversion.


   1.2 How does it work?

Well, this is the tricky part. The details are described in section 3, but
I'll try to make a start from here. I assume that everybody understands the
importance of partitioning. I also assume that most of you understand how
partitioning is achieved. For those who don't, here it is:

Partitioning is just a marking of territories on the physical disk's surface.
At the first sector of the disk (sector 1, head 0, cylinder 0) resides an
executable code block, which looks for the bootable partition, and runs
it's boot sector code. That sector contains the information needed to
divide the disk space into partitions. Later on, the boot sector (which is
created by the OS's format utility) loads the OS Kernel (in DOS's case it
loads the IO.SYS and the MSDOS.SYS), which continues the job by loading
the information of all the partition structure into memory.

Partition Resizer does two things: When moving, apart from moving the data,
it changes the information contained in the partition structure. When
resizing, it changes the file system's data, which is contained in the
boot sector and the FAT area. Both partition and FAT FS structures are
explained at section 3.


   1.3 Is it safe?

A great deal of changes has been done to the resizing engine for version
1.3.0. The program has been known to work fine in most cases, but I've had
two e-mails reporting data loss. Both cases were caused by a bug that is now
corrected. Of course there has been lots of testing from my part, and from
many users that used the program in their systems, so the probability for
more critical bugs is highly unlikely. In case you find a problem, please
inform me ASAP. In order to avoid trouble, you should backup the most
valuable data in your disk, those that cannot be replaced. If something
happens, you'll only have to reinstall what's lost.

Most of the partition combinations this program has been tested with are
combinations created with DOS's (or Windows') FDISK, or compliant to it. If
you have created a partition structure which is not compatible with DOS, the
program will most probably encounter problems and refuse to work with the
offending disk in order to protect your data. The typical DOS partition
structure is described later on in this document (section 3).

The program utilises a special recovery mechanism that allows resumption of
the resizing or moving process even if it is interrupted by a reboot (most
probably due to power failure). Without this recovery mechanism, if the
program was interrupted during the resizing or moving process, it would be
impossible to access the partition's data again. This program stores every
single step, so it always knows what the last action was. For speed and
safety reasons I use the CMOS's bytes 1,3 and 5 (the alarm bytes) to store
the step counter number. Because the contents of the CMOS are preserved even
when the power is off, the program can always find the last step and continue
its work like nothing happened. If you don't believe it, test it.

There is one problem I do not prevent: Bad sectors. In case your disk has
bad sectors, the program will not run, in order to protect your data. It will
make a surface scan before it starts, but if you are certain that your disk
is free of defects, you may skip it. It would be better if you had your disk
surface scanned with a commercial program (like Norton Disk Doctor or
Windows' ScanDisk) before you run Partition Resizer.

And note this: The program can be *really* dangerous, if you don't follow
ALL precautions described in the README.1ST file. Please read it carefully
before using the program.


   1.4 Changes made to the previous version

-Fixed a bug with multiple primary non-FAT partition moving
-Fixed a graphics mode problem with some Graphics cards that default to
 16 pixel character height
-Fixed a problem with the 2nd option (you'll now be able to change a FAT16
 partition's cluster size)
-Minor documentation update



2- Working with Partition Resizer

   2.1 Safety Precautions

As with every program that messes with your data, you should be extra
careful. It is not difficult to make a mistake that will cost you valuable
data. So, you MUST follow carefully the instructions contained in the
file README.1ST, in order to ensure data safety. It would be a good idea
to print TROUBLE.DOC file in order to have it available when something
wrong happens.


   2.2 Running the program: What does what

The program will first look for the disk characteristics, it will scan the
partition information, and it will identify and check all the DOS partitions
of the disk. After some basic checks, it will continue with the main menu
of the program. Here you have 4 choices.

The first is resizing/moving a DOS partition or an extended partition. This
option will resize a partition in order to make free space for a new
partition to be created. It will also grow a partition if there is
unallocated space available and the cluster size is big enough. You can also
move the partition in the empty space. This way you will be able to change
the order of the partitions in the disk. You can also resize extended
partitions.

The second option is used to change a FAT16 partition's cluster size. This
will help you to make a small new partition able to grow up to any size you
want. This option should be used ONLY on empty and formatted partitions,
since it deletes all the data inside the partition.

The third option will show you detailed information for every partition on
the disk. This may sometimes help you find out which partition you want to
move or resize.

The last option will exit the program, and if you made any changes to the
partition structure it will immediately reboot the machine, so that the new
information will be loaded from the disk.

Every choice but 4, will lead you to a menu where you will be asked to choose
the partition which should be modified. Just enter the partition's number
and press enter. Every partition description can have up to four flags. The
first flag can be either P,L or E. These letters stand for Primary, Logical
and Extended partition respectively. The flag * shows that the specified
partition can be resized. Only partitions with * can be resized. The flag #
shows which partitions can be moved. The flag ! shows that a partition is
incompatible with the program, therefore it cannot be moved or resized. All
partitions can be moved, but this is not always safe. I have tried moving FAT
and HPFS partitions successfully, but I cannot be sure for every partition
type. If you decide to move any other partition type but FAT, you will be
proceeding at your own risk. The Drive letter indicated for a partition is
the one originally assigned by DOS. Usage of some software drivers, like
DblSpace or Stacker might alter the original drive letters.

The user interface for resizing/moving partitions has been greatly simplified:
appart from the use of graphics that make understanding the disk map easier,
the most important functions of Partition Resizer are accessible through this
screen. Using the Tab key, you can toggle between moving and resizing the
currently selected partition. For advanced users, the space bar displays
the extended partition of the disk and allows manipulation of its ends.
By default, the extended partition is concealed, allowing the user to
manipulate other partitions in a much simpler and effective way. Once
finished, press enter to continue and accept the confirmation question.

The screen will now clear, and you will be asked whether you want to perform
a surface test or not. This is not necessary if you know that your disk
is free of defects or if you performed a surface test recently, since
it will take some time (from several seconds to 15 minutes, depending on the
size of the partition). If you are uncertain, perform the surface test, since
bad sectors can be dangerous to your data. If the program finds any bad
sectors, it will quit immediately. If the surface test concludes normally,
the program will start performing the requested changes. This may take from
a few seconds to a few hours, so be prepared. If the program is terminated
abnormally, p.e. in case of a power shutdown, don't worry, you can always
reboot and run the program again. It will continue exactly from the point it
stopped. After it finishes, you may proceed with more changes, or exit the
program, which will boot your machine.

Sounds easy? Well, it should be. But if you are confused, you better check out
what's on the next section, just to get an idea about the whole partitioning
system. If you still have questions, you can get help from friends, or contact
me via my Internet addresses (see the end of this document). If you don't have
access to Internet, you can send me a letter (postcard preferred) and I will
try to help you as much as I can. Don't forget to tell me details about your
system, your partitions, and send me a copy of the PRESIZER.LOG file.


   2.3 Command Line Parameters

Partition Resizer's execution can be customized to suit your needs with the
following command line parameters:

/drive:#	When scanning for available physical drives (hard disks),
		Partition resizer will ignore all other drives except for the
		one specified in this parameter. # stands for the drive
		number (hard disk C: is number 0, D: is 1 and so on). For this
		version of Partition Resizer, only one drive can be specified
		each time the program runs.
/ignsectsize    When the error message "Sector size other than 512 bytes"
                (Error 2) occurs, if you are certain that the sector size of
                your disk is definitely 512 bytes, use this switch to bypass
                the error. Be very careful though, because if the sector size
                is not 512 bytes, using this switch might have unpredictable
                results.
/killrescue	If Partition Resizer was interrupted while resizing a
		partition, the next time it runs it will ask you to resume the
		operation. If you DO NOT WANT Partition Resizer to EVER resume
		the interrupted operation, use this option to permanently
		delete the rescue file and cleanup. This is a DANGEROUS
		parameter, since, if the resizing process is not resumed after
		abnormal interruption, the partition that was being processed
		(and in extreme cases other partitions as well) may be
		completely trashed.
/newlog         Creates an empty log file. By default, new log entries are
		appended to the existing log. This option allows to overwrite
		the existing entries.
/noboot		This switch forces the program to exit without rebooting
		after changes to the partition structure and/or file systems
		have been made. This is a DANGEROUS option, since if the
		user attempts to use the modified partition(s) before the
		machine is restarted, major damage can occur to the data.
/readonly	This switch allows the user to execute the program and modify
		partitions (resize or move them) without actually making any
		change whatsoever. The switch directly disables the disk
		write routine which is the only part of the program that can
		perform actual modifications to the disk. Therefore, this
		switch can be safely used for testing purposes, since all
		other functionallity (logging, rescue file creation etc.) will
		be available. Warning: because of slight changes to the rescue
		system, which now uses disk writing to extend the counter
		range, in some extreme cases the resumption process may not
		work correctly if this switch is specified. This is because
		the overflowing digits of the counter will be ignored.
		This has no impact on the disk integrity, but it may give
		false results (resumption may start at a step earlier than
		expected) IF the program is interrupted and the process is
		resumed.
/textmode	If you have any problems using the graphical interface, use
		this switch to work with an alternative (and similar to the
		graphic) interface in text mode. The text mode interface
		still provides full functionallity, but visual aid is less
		accurate and informative.


3- Technical Matters

   3.1 The partition system

The partition system is one of the most important things on the disk
subsystem. It is a standard beyond File Systems and Operating Systems.
The partition structure looks very much like the DOS directory structure.
The root directory here is the root sector, the first sector of the disk.
When the machine boots, bios loads this sector at address 7C00:0000,
and jumps there. As you understand, there is code written at the beginning
of that sector. This code searches the primary partition list to see which
one is bootable, then loads its first sector (the boot sector) at the same
address (7C00:0000) and it jumps there. After that, it is the operating
system that takes control.
Let's see some more details. Here is a detailed map of the root partition
sector (sector 1, head 0, cylinder 0) (you may often see it as MBR, master
boot record):

Offset             Description

0x000-0x1BD        Boot code
0x1BE-0x1CD        First Primary partition descriptor
0x1CE-0x1DD        Second Primary partition descriptor
0x1DE-0x1ED        Third Primary partition descriptor
0x1EE-0x1FD        Fourth Primary partition descriptor
0x1FE-0x1FF        System Signature word (0xAA55)

Boot code is the executable code that was described above. The partition
descriptors have the following form:

Offset             Description

0x0                Boot marking
0x1                Head                    \
0x2                Sector & Cylinder 8-9    >  Starting location
0x3                Cylinder 0-7            /
0x4                System Description
0x5                Head                    \
0x6                Sector & Cylinder 8-9    >  Ending location
0x7                Cylinder 0-7            /
0x8-0xB            Relative sector
0xC-0xF            Number of sectors in partition

Boot marking is a byte value, which can be either 0 or the drive number
(0x80). If it is 0x80 then the partition is the active partition of the
disk (boot partition), and that's where the system boots from. The next
3 bytes contain the head, cylinder and sector where the partition begins.
Sector and cylinder are stored in two bytes. Bits 0-7 of the cylinder
value are stored in the second byte, while bits 8-9 are stored at the
high bits of the first byte. The sector value is stored at bits 0-5 of the
first byte. So, the word is bitmapped like this:

FEDCBA98 76543210
CCCCCCCC CCSSSSSS
76543210 98543210

where C are Cylinder bits (the number below shows which cylinder bit is
which) and S are Sector bits. Right after is the system byte, which is
the identification byte for the partition. A value of 0 means that the
partition is not being used, while other values depend on the file system.
DOS uses values 1,4 and 6 for FAT12, FAT16 and BigDOS partitions respectively.
A value of 5 means Extended partition, which is explained later on.
Next, there is the ending location (sector) of the partition, and later on,
the relative sector value. This is a number that shows the position of the
partition relative to the present sector. So, for primary partitions, it's
the starting sector of the partition (Primary partitions are the partitions
that are described in the root of the partition structure. As we will see
later on, there are partition descriptors in other places on the disk as
well, which are called logical drives). The last item of the descriptor,
is the partition length (in sectors).

When the disk is operating in LBA mode, the CHS (cylinder-head-sector) values
for starting and ending location are ignored. Mapping of the drive is not
done in terms of CHS but with an absolute sector number. Thus, relative sector
value and partition length are used for identifying the partition's territory
on the disk. For disks greater than 8.4GB in size, CHS values are always
invalid.

In the root sector, there is space for 4 descriptors. Right after them, there
is a word value of 0xAA55, which marks the sector as system sector. This
value exists on every sector of the partition structure (including boot
sectors) and if it doesn't exist, then the structure may probably be damaged.

Now, concerning extended partitions, they are described as any other partition
in the root sector, but their treatment is different. These partitions are
specifically treated by the Operating Systems. They point to a sector which
contains partition descriptors for other partitions and extended partitions,
and so on. This is how we can have more than 4 partitions on a disk. Let's
see a small graphic (sic) example:

MBR     1st Ext         2nd Ext         3rd Ext
       -----------------------------------------------------
1:p    | 1:l           | 1:l           | 1:l               |
2:p    | 2:e-----------| 2:e-----------| 2:-               |
3:e----| 3:-           | 3:-           | 3:-               |
4:p    | 4:-           | 4:-           | 4:-               |
       -----------------------------------------------------

In this example, we see a map of a partition structure. MBR stands for
Master Boot Record (root sector) and 1st, 2nd and 3rd Ext stand for
1st, 2nd and 3rd Extended partition nodes. 'p' stands for primary partition,
'e' stands for extended partition and 'l' stands for logical drive.
The 'e' partition in the MBR, is called main or root or primary extended
partition. This is because the whole extended partition structure is depending
on that partition. Now, the starting location of the primary extended
partition points to the 1st extended partition. The space that the primary
extended partition allocates, is reserved for logical drives. The 1st
extended partition (and the rest as well) contain information about their
respective logical drives, in a way identical to the MBR (described above),
but without the boot code part. Every extended partition has 4 descriptors
as well, but only the first two are used: the first one identifies the
corresponding logical drive, and the second contains and extended partition
entry pointing to the next logical drive in the partition chain. So, the
partition structure is a linked list structure, which can be as long as we
like. (Every extended partition description sector has the 0xAA55 signature
at its end, to identify it as a system sector).

There are some geometry restrictions for partitions. Partitions must start at
the beginning of a cylinder, and end at a cylinder's end. This is that
starting location must always be Cyl: XXXX  Head: (0 or 1)  Sector 1 and the
ending location must be Cyl: YYYY  Head: k-1  Sector l, where k is the number
of heads of the physical disk, and l the number of sectors per track of the
physical disk. Also, if you delete one of the middle logical drives, (p.e.
the 2nd Ext.) then the previous extended partition will be connected directly
to the next, replacing the link. Geometry restricions are also effective in
disks that work with LBA translation.

If you want to see the whole thing yourself, you can make your primary DOS
partition smaller, and create some new logical drives just to play with
them. You can get much help from a commercial Disk Editor, and you can of
course play with Partition Resizer.


   3.2 The DOS (FAT16 and FAT12 only) filesystem structure

The MBR executable code will load the boot partition's boot record. This
is the second step of the booting procedure. And this is where the whole
thing differs from OS to OS. We will only look at DOS's proceedings for now,
since the rest OS's are less documented and more complicated (although on the
next version of Partition Resizer I'll manage to resize OS/2 partitions, and
if I get lucky enough, why not NTFS...).

The DOS partition is rather simple: The first sector is the boot sector,
right after there are two copies of the FAT (File Allocation Table), right
then we have 32 sectors for the root directory, and finally we have clusters
0 and 1 (unused) and later on the rest of the clusters.

The Boot record, is an executable code block, which is loaded by the MBR,
and it makes some preparation in order to load the IO.SYS file, which is
the DOS kernel (if we can call it a kernel... ;-)). This is useless to us,
since only the processor can understand machine code, but the boot sector
also contains useful information. This information begins at offset 3 of
the sector and contains the following:

Offset            Description
0x03-0x0A         OEM ID: This is a small string written by the formatter.
0x0B-0x0C         Bytes per sector: This is always 512 (it depends on the
		  physical disks characteristics). If you have a disk with
		  a different value, please don't hesitate to inform me.
		  Partition Resizer WON'T WORK FOR DISKS WITH SECTOR SIZE
		  OTHER THAN 512!
0x0D              Sectors per Cluster: The cluster is the basic block of
		  information on a FAT drive. A FAT drive cannot have more
		  than 65527 clusters. This size can limit the maximum size
		  a partition can reach after resizing.
0x0E-0x0F         Reserved sectors at beginning: This is normally 1, the
		  boot sector. After these sectors, begins the FAT area.
0x10              FAT copies: Number of FAT copies. Normally there
		  are two copies of FAT.
0x11-0x12         Root directory entries: This is normally 512. This shows
		  the maximum number of files and directories that root
		  directory can hold. This is because the root directory has
		  a constant length (512 entries * 32 bytes/entry /
		  512 bytes/sector = 32 sectors)
0x13-0x14         Total sectors on disk (small): If we have less than 65536
		  sectors in the partition, this value contains the number.
		  If it's more, then the number is stored in bytes 0x20-0x23.
		  This is an entry that was left from the old DOS versions,
		  when partitions could have up to 65536 sectors.
0x15              Media descriptor byte: This byte is always F8 for hard
		  disks.
0x16-0x17         Sectors per FAT: This shows how many sectors does each FAT
		  take up. This depends on how many clusters the partition
		  has, and what is the FAT type (12bit/16bit). This can be
                  from 1 to 256 sectors.
0x18-0x19         Sectors per track: Same as the physical disk's sectors per
		  track value.
0x1A-0x1B         Sides: Same as the physical disk's head number.
0x1C-0x1F         Special hidden sectors: This is how many sectors exist
		  between the partition's description sector and the boot
		  sector. Usually one track.
0x20-0x23         Big total number of sectors: If we have more than 65536
		  sectors in the partition, their number is written here.
0x24-0x25         Physical drive number: This is the physical drive number
		  (c:0x80, d:0x81 etc.).
0x26              Extended boot record signature: This marks an extended
		  boot record. If it is 29, the disk was formatted by DOS
		  4.0 or later.
0x27-0x2A         Volume serial number: This is the partition's serial number.
0x2B-0x35         Volume label: This is the partition's label string.
0x36-0x3D         FS ID: This is a string that identifies a partition as
		  12bit FAT or 16bit FAT.

This is a detailed description of the boot record information. This will
help you to understand more about the FAT file system.

The boot sector is the first sector of a DOS partition. The number of
reserved sectors (which is normally 1) shows how many sectors we have before
the FAT area. So in most cases, the first FAT sector is sector 2 of the
partition (from now on, every sector number will be taken relatively from
the beginning of the partition). The first FAT, who's length is given
in the boot sector, contains entries that mark the partition's space
allocation. Every file has a small descriptor of 32 bytes, which resides in
its directory area (not in FAT). The directory area is itself a file, which
is described in its parent directory, and so on until we reach root directory,
which is a constant area in the partition (we'll see that later on). A word
value in the file descriptor, tells DOS which is the file's first cluster.
FAT consists of word values (or 12bit values if it is a 12bit FAT system),
which begin from the first sector, and continue until the last one. Every
value represents a cluster, which one is depending on the value's offset from
the FAT's beginning. So, the 3rd word of the FAT stands for the 3rd cluster
of the partition, and so on. So when DOS knows a file's first cluster, it's
looking it up to find the value that is stored in the FAT's respective
position. That value points to the next cluster of the file, and so on, until
an EOF marking of 0xFFFF is found (0xFFF for 12bit FAT). Empty clusters are
marked with 0 and bad clusters with 0xFFF7. This is how FAT works. Now, the
first two positions of the FAT are reserved, and they have an identification
code which is 0xFFFFFFF8 (0xFFFFF8 for 12bit FAT).

The rest FATs (2nd, 3rd etc.) are identical to the first one. They are
exact copies of the first FAT, and they begin right after the end of the
first FAT. Right after the last FAT, resides the root directory. This is
normally 32 sectors long, and contains 32 byte entries which describe the
root directory's files and directories. Right after the root directory,
begins the first cluster (cluster 0) which is unused, and so is for cluster 1.
Right after these two clusters, begins the user's space, where the files are
stored.

This is the whole story about DOS's file system. This file system was designed
to be fast (it's very easy to find the unallocated space) but it has certain
disadvantages: One is the very large amount of unused space, which is caused
by the use of clusters. For example, if you have a 340MB disk, you have to
use 8192 bytes cluster size (16 sectors). This means that, if you write
a file that is 1 or several bytes long, you will consume space of 8K. This
could be resolved if we could use more than 65536 clusters in a DOS partition,
which could mean a 20bit fat or more, in order to have clusters of 1 sector.
Since this is not possible, there is another solution: Why should I have
one partition with 8K cluster size, and not 2 partitions with 4K cluster size?
The loss is lowered dramatically, and it would save many megs. This is not
though always possible, since changing cluster size without loosing the
existing data is quite complicated. I have decided not to add such
functionality to the program, since the new Windows filesystem, FAT32,
permanently solves the allocation problem. I strongly recommend the conversion
of your existing FAT16 partitions into FAT32. This can be easily done with
the use of the conversion utility provided by Microsoft and included in
Windows 98 System tools collection.


   3.3 The Windows FAT32 filesystem structure

The FAT32 filesystem is quite similar to the FAT16 filesystem. The following
differences exist:

-FAT entries are now 32bit wide, allowing for a maximum of approximately 200
milion clusters in a single partition (actually, each FAT entry is 28bit wide,
the upper 4 bits are reserved for future use and must always be 0).
-The boot sector's information has been changed (see the table below)
-The root directory does not necessarily reside in the beginning of the drive
and it can grow to any size desirable.
-FAT mirroring can be disabled

In details, the boot sector entries are the following:

Offset            Description
0x03-0x0A         OEM ID: This is a small string written by the formatter.
0x0B-0x0C         Bytes per sector: This is always 512 (it depends on the
		  physical disks characteristics). If you have a disk with
		  a different value, please don't hesitate to inform me.
		  Partition Resizer WON'T WORK FOR DISKS WITH SECTOR SIZE
		  OTHER THAN 512!
0x0D              Sectors per Cluster: The cluster is the basic block of
		  information on a FAT drive. A FAT drive cannot have more
		  than 65527 clusters. This size can limit the maximum size
		  a partition can reach after resizing.
0x0E-0x0F         Reserved sectors at beginning: first FAT sector number
		  (0 based)
0x10              FAT copies: Number of FAT copies. Normally there
		  are two copies of FAT.
0x11-0x14         Reserved, must be 0.
0x15              Media descriptor byte: This byte is always F8 for hard
		  disks.
0x16-0x17         Reserved, must be 0
0x18-0x19         Sectors per track: Same as the physical disk's sectors per
		  track value.
0x1A-0x1B         Sides: Same as the physical disk's head number.
0x1C-0x1F         Special hidden sectors: This is how many sectors exist
		  between the partition's description sector and the boot
		  sector. Usually one track.
0x20-0x23         Big total number of sectors: If we have more than 65536
		  sectors in the partition, their number is written here.
0x24-0x27         Big Sectors per FAT value (old SPF value is now reserved).
0x28-0x29         Flags used for specifying FAT mirroring properties.
0x2A-0x2B         Major and minor version of the file system.
0x2C-0x2F         Root start: The first cluster (start) of the root directory.
0x30-0x31	  File System sector number: offset of the file system sector
		  (see below).
0x32-0x33	  Backup Boot Sector: offset of the backup copy of this
		  sector.
0x34-0x3F	  Reserved.
0x40              Physical drive number: This is the physical drive number
		  (c:0x80, d:0x81 etc.).
0x41		  Reserved.
0x42              Extended boot record signature: This marks an extended
		  boot record. If it is 29, the disk was formatted by DOS
		  4.0 or later.
0x43-0x46         Volume serial number: This is the partition's serial number.
0x47-0x51         Volume label: This is the partition's label string.
0x52-0x59         FS ID: This is a string that identifies a partition as
		  FAT32.

After this boot sector, the File System Sector exists, containing the
following information:

0x1E8-0x1EB	  Free cluster count: contains the number of free clusters
		  in the drive (used to speed up free space calculation). If
		  it is -1 the value is recalculated.
0x1EC-0x1EF	  First free cluster: number of the first available cluster
		  in the partition.

I will not go into more detailed explaination of the FAT32 file system. For
more information, please visit the Microsoft Developers Library at
http://www.microsoft.com/msdn and go to SDK Documentation - Platform SDK -
Windows Base Services - Windows 95 Features - Windows 95 Reference -
FAT32 API Reference - Structures.


4- Partitioning Techniques

   4.1 Deciding what you want

Well, OK, you've got the program. But now what happens? Where will you
create the proper space for a new partition? And which partition is the one
you want to shrink or grow? How should you place the partitions in the
empty space to order them as you like? How will you grow a partition which
refuses to grow more?

First of all, you have to decide what you want. Take a look at the partition
list that FDISK or Partition Resizer provide you. Decide which partitions
you need to resize. You may recognise them by their size, drive letter or
serial numbers. Then you'll have to think what the new sizes will be. Remember
that what's inside the extended partition cannot get out of it, and what's
outside cannot get inside either.

Now, here are some useful techniques to use in certain situations. Just take
a look to see if they meet your needs.


   4.2 Merging many small partitions into a larger one

Sometimes, you get your disk divided into three or four partitions, which
is not a useful thing. Until now, the only solution was to backup all
your data, delete the whole partition structure, and then create a large
partition to put your data inside. Partition Resizer can resolve the
problem without any backing up. It's much faster and easier. Just do the
following:

a. Decide which partition will be the one to remain. Normally, you should
choose a primary partition. The problem is if it can grow enough. Decide
what is the size the partition will finally grow to, and check if your
primary partition can grow to that size. If it can't, go to step b, otherwise
read step c.

b. If you want to create a partition that can grow enough for your needs,
you will have to empty your primary partition. To do this, you have to
shrink it to its minimum, while growing a logical drive. This can be done by
shrinking the primary partition, expanding downwards the extended partition,
moving the first logical drive to the beginning of the extended partition,
and growing it to the max. Then, exit the program, move as much files as you
can from the primary partition to the grown logical drive, defrag the
primary partition, and repeat step b until the primary partition is empty.
When you empty it, use the program to change its cluster size that matches
your needs. You can provide the program with the desired size, which is the
size you want the partition to have when you finish the whole process.
Partition Resizer will then suggest you a cluster size to apply to the
partition, which is the optimum size for the given desired partition size.
If this was your boot partition, you will have to make it a system partition
again, so run SYS to do that.

c. Now that your primary partition is able to grow enough, start moving
data into it. Try to get data from small partitions, so that you can
finish with them early and get rid of them. If you filled up the primary
partition and there's still data in the partition which you are emptying,
move data from the emptying partition to other partitions, in order to
empty it faster. When the partition is empty, you can delete it with FDISK.
If you cannot empty it, then defrag it, shrink it to its minimum, and move
it to the end of the empty space created, grow the previous partition to
reclaim the empty space created, exit the program, and move the rest of the
data remaining into the grown partition. Repeat this until you empty the
partition, and then delete it with FDISK.

d. One of the small partitions is now deleted. You can now move all the
other logical drives to the end of the empty space, and resize the extended
partition in order to make more space to grow the primary partition. Then
choose another partition and repeat step c until you empty and delete all the
logical drives. With the last one, you can delete the extended partition
too. And presto! You can now grow the primary partition to fill all the
empty space in the disk.


   4.3 Splitting a partition in two

This technique is much alike the previous one. Suppose you have one primary
partition, and you want to split it in two partitions. This is faster and
easier than the previous procedure, just do the following:

a. Defrag the primary partition, and then shrink it to the minimum. This way,
you will create empty space for the new partition.

b. Using FDISK create an extended partition, and then a logical drive in it.
Format the logical drive, and run Partition Resizer. You will now have to
decide the final size of the new partition, in order to change its cluster
size while it is still empty. When you decide the final size, choose the
third option of Partition Resizer's main menu, and give as desired size the
size you decided. The program will suggest you a cluster size that is optimum
for the partition, and you should apply that size.

c. When you finish creating and modifying the new partition, exit the program,
and move the data you want in the new partition. Then, shrink the primary
partition again (defraging is necessary here) grow the logical drive to the
maximum. Repeat this step, until you reach the desired size.


   4.4 Playing with partitions' sizes and positions

And now, some general advice about partition resizing:

a. When shrinking a partition, always defrag it first. This will leave
space at the end of the partition, which will be freed by the program. The
less space you have at the end of the partition, the less the shrinking will
be. When defraging take special care for the unmovable files: They must be
moved too, so change their attributes before defraging the disk. System
files are a special case of unmovable files. You must be extra careful with
these. Check the TROUBLE.DOC to see more info about the system files.

b. Although Partition Resizer can move primary partitions, you will rarely
need to do this. You should always leave your DOS primary partitions in their
original place, unless you absolutely need to move them. This will not harm
the partition, but it might leave unused space before the primary partition
which will never be used by DOS's FDISK. Warning: if you move a primary DOS
partition, you might not be able to boot from that partition!

c. If you want to install a new operating system, you may have to delete
much of your data in the DOS partition, since you cannot move that data in
the new partition. So, you will only have to shrink your DOS partition once.

d. Always follow the safety rules described in README.1ST. Playing with your
data can be REALLY dangerous sometimes, so be very careful.


   4.5 Lack of features and possible workarounds

Partition Resizer required a lot of time for its development and the
development of its upgrades. Time which was spent solely by me, and which is
of course valuable. I never regret the time I spent on this project, and I
feel that my efforts have been paid off by the success of the program in an
international level.

There are though some features that Partition Resizer always lacked, and will
probably continue to lack, because I believe that they are not necessary or
workarounds can be used instead, while the time and effort they require for
development is more than what I can invest (or am willing to invest). These
features and possible workarounds are the following:

Problem: 	Partition Resizer does not resize non-FAT partitions.
Workaround:	Nothing I can think of... another program maybe?

Problem:	Partition Resizer does not change the cluster size in a
		non-destructive way.
Workaround:	Several workarounds exist. The best in my opinion, that is
		of course if it can be applied, is to change the filesystem
		to FAT32. This will create partitions with minimal cluster
		sizes (4K) and practically unlimited maximum size. If FAT32
		is not available, then try creating a new partition of the
		desired cluster size, and move the data in there (see
		PRESIZER.FAQ for a more detailed description of the process)

Problem:	Partition Resizer does not perform creation or deletion
		of partitions.
Workaround:	FDISK does. Please use it.

Problem:	Partition Resizer's user interface sucks.
Workaround:     Pretend you like the user interface.


5- Credits and addresses

There used to be a huge list of thanksgivings here, but I decided that it
will take ages to update it (especially after 6 years). So I will briefly
(but not less intensively) thank all of the people who helped the creation
and continuous development of this program, with their suggestions, their
feedback, and most of all their support that comes from the appreciation of
my work.

I also thank you, for spending the time to read this document and for
using my program. I hope that the technical info included in here will
seriously help many of you to create your own programs. If you find this
program useful, you can always send me a postcard to the following address:

	John Lagonikas
	17 Lycourgou Str.
	16675 Glyfada
	ATHENS, GREECE

Since the e-mail flow concerning the program is always increasing, and reached
a peak of several messages per day that had to be answered in detail, I would
kindly request that you think twice before asking for advice or information.
So, please, before sending the message, take a look at PRESIZER.FAQ to see if
the answer to your questions (or your prayers) is in there. Please try to find
some different passive sources (web pages, documentation, books etc.) that
might help solving your problem. If all else fails, try contacting me at the
address:

	presizer@zeleps.com

Commentary e-mail is welcome, but it will probably not be answered.

The official home page of Partition Resizer is currently (31/12/00) located
at:

	http://zeleps.com/

If you cannot find the page at this location for any reason, you can perform
a Web search with the keywords "Partition Resizer Zeleps" to locate it.


Thank you again for reading this document and for using Partition Resizer!

			       ------||------
